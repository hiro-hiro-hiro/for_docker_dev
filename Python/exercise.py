# -*- coding: utf-8 -*-
"""Option calculated by Monte Carlo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f1KW5dHXVr8r6jY3gncshaUoVtQ8jLQ0
"""

# please install the following library
# !pip install sobol_seq

#import sobol_seq
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import norm


# analytical solution
def BS_european_call_analytic(r, sigma, T, S0, K):
  d_plus = (np.log(S0/K) + (r + sigma*sigma/2) * T) / (sigma * np.sqrt(T))
  d_minus = d_plus - sigma * np.sqrt(T)
  return S0 * norm.cdf(d_plus, 0, 1) - K * np.exp(-r*T) * norm.cdf(d_minus, 0 ,1)


# calculated by Monte Carlo 
def BS_european_call_prototype(N, r, sigma, T, S0, K):
  Stock = S0 * np.exp((r - sigma*sigma/2) * T + sigma * np.sqrt(T) * np.random.randn(N)) 
  Value = np.exp(-r*T) * np.maximum(Stock - K, 0.0)
  return np.mean(Value), np.std(Value, ddof=1)

# calculated by Monte Carlo with Control Variates method
def BS_european_call_CVM(N, r, sigma, T, S0, K):
  Stock = S0 * np.exp((r - sigma*sigma/2) * T + sigma * np.sqrt(T) * np.random.randn(N)) 
  Value = np.exp(-r*T) * np.maximum(Stock - K, 0.0)
  b = np.cov([Stock, Value], bias=1)[0, 1] / np.var(Stock)
  Vb = Value - b * (Stock - np.exp(r*T) * S0)
  Vb_std = np.sqrt( sum(np.power(Vb - BS_european_call_analytic(r, sigma, T, S0, K), 2)) / N )
  return np.mean(Vb), np.std(Vb, ddof=1)

# calculated by Monte Carlo with Antithetic Variates method
def BS_european_call_AVM(N, r, sigma, T, S0, K):
  Z = np.random.randn(N)
  Stock = S0 * np.exp((r - sigma*sigma/2) * T + sigma * np.sqrt(T) * Z) 
  Stock_sym = S0 * np.exp((r - sigma*sigma/2) * T + sigma * np.sqrt(T) * (-Z))
  Value = np.exp(-r*T) * np.maximum(Stock - K, 0.0) 
  Value_sym = np.exp(-r*T) * np.maximum(Stock_sym - K, 0.0)  
  return (np.mean(Value) + np.mean(Value_sym))/2, np.std((Value + Value_sym)/2, ddof=1)



# https://rosettacode.org/wiki/Van_der_Corput_sequence
# make van der corput sequence
def Van_Der_Corput(n, base):
  vdc = 0
  denom = 1
  while n:
    denom *= base
    n, remainder = divmod(n, base)
    vdc += remainder / denom
  return vdc

# calculated by quasi-Monte Carlo with van der corput sequence
def BS_european_call_VDC(N, r, sigma, T, S0, K):
  Z = norm.ppf([Van_Der_Corput(i, 2) for i in range(N)]) 
  Stock = S0 * np.exp((r - sigma*sigma/2) * T + sigma * np.sqrt(T) * Z) 
  Value = np.exp(-r*T) * np.maximum(Stock - K, 0.0)
  return np.mean(Value), np.std(Value, ddof=1)

# calculated by quasi-Monte Carlo with sobol sequence 
#def BS_european_call_Sob(N, r, sigma, T, S0, K):
#  Z = norm.ppf(sobol_seq.i4_sobol_generate(1, N).flatten())
#  Stock = S0 * np.exp((r - sigma*sigma/2) * T + sigma * np.sqrt(T) * Z) 
#  Value = np.exp(-r*T) * np.maximum(Stock - K, 0.0)
#  return np.mean(Value), np.std(Value, ddof=1)



# comparison of results
def make_figure_and_table(base, pow): 
  
  r = 0.05      # risk-free rate
  sigma = 0.25  # volatility
  T = 1         # maturity
  S0 = 100      # option price
  K = 110       # strike price

  # the frequency of random number generation
  num = [base**i for i in range(1,pow+1)]
  # make standard deviation array
  pr_std = [BS_european_call_prototype(base**i, r, sigma, T, S0, K)[1] for i in range(1,pow+1)]
  cv_std = [BS_european_call_CVM(base**i, r, sigma, T, S0, K)[1] for i in range(1,pow+1)]
  av_std = [BS_european_call_AVM(base**i, r, sigma, T, S0, K)[1] for i in range(1,pow+1)]
  vd_std = [BS_european_call_VDC(base**i, r, sigma, T, S0, K)[1] for i in range(1,pow+1)]
  #so_std = [BS_european_call_Sob(base**i, r, sigma, T, S0, K)[1] for i in range(1,pow+1)]

  # plot standard deviation of set_count trials  
  plt.plot(num, pr_std, 'o:', label = 'normal')
  plt.plot(num, cv_std, '^:', label = 'control variates')
  plt.plot(num, av_std, 's:', label = 'antithetic valiates')
  plt.plot(num, vd_std, 'p:', c = 'gray', label = 'van der corput') 
  #plt.plot(num, so_std, 'h:', c = 'gray', label = 'sobol sequence')
  plt.xlabel('frequency of random number generation')  
  plt.ylabel('standard deviation')
  plt.xscale('log')
  #plt.yscale('log')
  plt.grid(True)
  plt.legend()

  # display standard deviation of set_count trials
  df = pd.DataFrame({'frequency':           num,
                     'normal':              pr_std,
                     'control valiates':    cv_std,                     
                     'antithetic valiates': av_std })
                     #'van der corput': vd_std,
                     #'sobol sequence': so_std })
  return print(df)



if __name__ == '__main__':
  make_figure_and_table(base=10, pow=6)